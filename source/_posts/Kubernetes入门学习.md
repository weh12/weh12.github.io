---
title: Kubernetes入门学习
date: 2024-11-03 19:00:02
categories: 教程
tags: Kubernetes
cover: https://pic.imgdb.cn/item/67275883d29ded1a8c878153.jpg
---
Kubernetes简介

Kubernetes是一个开源的容器编排平台

![](https://pic.imgdb.cn/item/67273c87d29ded1a8c733732.png)

用于自动化部署、扩展和管理容器化应用程序。以下是Kubernetes的一些关键特性和概念：

1. **容器编排**：Kubernetes帮助用户管理容器的生命周期，包括部署、运行、扩展、监控和更新。
  
2. **服务发现和负载均衡**：Kubernetes可以为容器提供内部和外部的负载均衡，并且能够自动发现服务。
  
3. **存储编排**：Kubernetes允许用户自动挂载存储系统，无论是本地磁盘、公共云提供商的存储还是网络存储系统。
  
4. **自动部署和回滚**：Kubernetes支持声明式的更新，可以自动回滚到之前的版本，如果新版本出现问题。
  
5. **自动完成声明式部署**：用户可以声明系统应有的状态，Kubernetes会自动将当前状态变更为期望状态。
  
6. **自动重启**：如果容器崩溃，Kubernetes会自动重启该容器。
  
7. **自动放置**：Kubernetes可以自动决定在哪个节点上运行容器，以优化资源利用。
  
8. **密钥和配置管理**：Kubernetes可以存储和管理敏感信息，如密码和密钥，并将其传递给容器，而无需在堆栈配置中暴露。
  
9. **扩展性**：Kubernetes的API使得开发者可以轻松开发自定义的扩展插件。
  
10. **集群联邦**：多个Kubernetes集群可以组成一个逻辑上的大集群，以便跨多个云或数据中心共享资源。
  

Kubernetes的核心组件包括：

- **Kubernetes Master**：负责调度Pods、处理集群事件等。
- **Node**：运行Pods的机器。
- **Pod**：Kubernetes中的基本部署单元，可以包含一个或多个容器。
- **Service**：定义了一种访问Pod的方式，它是一个稳定的接口，可以访问到Pods。
- **Deployment**：用于描述应用的期望状态，包括应用的副本数等。
- **Ingress**：管理外部访问应用的规则。
- **Persistent Volume (PV) 和 Persistent Volume Claim (PVC)**：用于存储的抽象，允许Pods使用持久化存储。
- **Namespace**：用于在同一个物理集群中隔离不同的用户或项目。

Kubernetes的设计目标是提供一个平台，它能够运行分布式系统，并具有高可用性、可扩展性和灵活性。它已经成为容器编排领域的事实标准，被广泛应用于生产环境中。

## Kubernetes组件

### Node基本信息

首先从一个最简单的节点开始, 一个节点就是一个物理机或者虚拟机, 在这个节点上我们可以运行一个或多个pod, Pod是kubernetes的最小调度单元, 一个pod就是一个或多个应用容器的组合, 它创建了一个容器的运行环境, 在这个环境中, 容器可以共享一些资源, 比如网络 存储以及一些运行时的配置等

假设我们的系统包括一个应用程序和一个数据库, 就可以将应用程序和数据库分别放到两个不同的pod中, 一般情况下, 我们建议一个pod中只运行一个容器, 但不是说一个pod中只能运行一个容器, 因为这样是为了实现应用程序的解耦和扩展, 一个pod可以有多个容器, 但是一般也仅限于这些容器是高度耦合的情况, 它们之间为了实现某种功能或者共享某些资源, 而不得不放到同一个pod中

![](https://s2.loli.net/2024/11/03/GCZUylR8YjpI3XB.png)

现在我们已经将应用程序和数据库, 分别放到了两个pod中, 应用程序要访问数据库的话, 就需要知道数据库IP地址, 这个IP地址是在Pod创建的时候自动分配的, 它是一个集群内部的IP地址

Pod之间可以通过这个IP地址来进行通信, 这样我们的应用程序就可以通过这个IP地址来访问数据库了, 但是这个有两个问题需要注意一下:

> 一个是这个IP地址是一个内部的IP地址, 在集群外部是无法访问的

> 二是pod并不是一个稳定的实体, 也就意味着它们非常容易被创建或者销毁, 在发生故障的时候, Kubernetes会自动销毁pod重新创建新的pod来代替它, 这个时候IP地址也会发生变化

为了解决问题二, Kubernetes提供了一个叫做`Service`的资源对象, 它可以将一组pod封装成一个服务, 这个服务可以通过一个统一的入口来访问, 拿刚才的例子来说, 我们可以将应用程序和数据库的pod分别封装成两个Service(服务), 这样应用程序就可以通过Service的IP地址来访问数据库, 当pod发生故障的时候, 即使它的IP地址发生了变化, 但Service的IP地址不会变, Service会自动的请求转发到其他健康的pod上, 以此来解决pod的IP不稳定的问题

### 内部和外部服务

Service也分内部服务和外部服务, 内部服务是一些我们不想暴露给外部的服务, 比如MySQL数据库 缓存 消息队列等等, 这些服务只需要在集群内部被访问就可以,

而相应的, 有些服务是要暴露给外部的, 比如一些微服务的后端API接口或者是一些给用户使用的前端界面等等

外部服务有几种常用的类型, 其中一种类型就是**NodePort**, 它会在节点上开放一个端口, 然后将这个端口映射到Service的IP地址和端口上, 这样就能通过节点的IP地址和端口来访问Service, 在开发或者测试阶段, 使用这种IP和端口号的方式是没有问题的, 但是在生产环境中, 通常都是通过域名来访问服务的, 这个时候就用到了另一个资源对象`Ingress`

Ingress是用来管理从集群外部访问集群内部服务的入口和方式的, 可以通过Ingress来配置不同转发规则, 从而根据不同的规则来访问集群内部不同的Service以及Service所对应的后端pod, 还可以通过Ingress来配置域名, 这样就可以将原本使用IP地址和端口号的方式, 转换成使用域名的方式来访问Service

另外Ingress也可以配置一些其他功能, 比如负载均衡 SSL证书等等

### 应用程序和数据库的耦合问题

举个例子, 比如我们的应用程序需要访问数据库, 通常的做法是把数据库的地址和端口等连接信息写到配置文件或者环境变量中, 然后在应用程序中读取这些配置信息, 但是这样的话配置信息就和应用程序耦合在一起了, 一旦数据库的地址或者端口发生了变化, 那么我们就需要重新编译应用程序, 然后再重新部署到集群中, 这样不但非常麻烦, 而且还会造成应用程序的停机时间, 这对于一些需要7x24小时不间断运行的系统或者服务来说, 显然是不能接受的,

为了解决这个问题, kubernetes提供了一个叫做`ConfigMap`的组件, 它可以将一些配置信息封装起来, 然后就可以在应用程序中读取和使用了

有了ConfigMap, 我们就可以把配置信息和应用程序的镜像内容分离开来, 这样就可以保持容器化应用程序的可以移植性, 当数据库的地址和端口发生变化的时候, 我们也只需要修改ConfigMap对象中的配置信息, 然后重新加载pod就行了, 不需要重新编译, 这样就实现了应用程序和数据库的解耦

> 有一点需要注意到, ConfigMap中的配置信息都是明文的, 如果配置信息中包含了一些敏感信息, 比如数据库的用户名或者密码等等, 那么就不建议存储在ConfigMap

为了解决这个小问题, Kubernetes提供了另一个叫做`Secret`的组件, 和ConfigMap类似, 它可以将一些敏感信息封装起来, 然后就可以在应用程序中使用和读取了, Secret只是做了Base64的编码并没有加密, 还要依靠Kubernetes的其他安全机制来保证系统安全

### 持久化存储

当容器被销毁或者重启的时候, 容器中的数据也会跟着消失, 这对于一些需要持久化存储的应用程序, 比如数据库来说显然是不行的

为了解决这个问题, Kubernetes提供了一个叫做`Volume`的组件, 它可以将一些持久化的资源挂载到集群中的本地磁盘上, 或者挂载到集群外部的远程存储上, 这样即使容器被销毁或者重启, 这些数据也不会丢失

### 应用程序的高可用性

举个例子, 比如如果应用程序所在的节点发生了故障, 或者需要对节点进行升级和更新维护的时候, 应用程序就会停止服务, 这样就有可能造成一些不必要的麻烦和损失

解决方案其实也非常简单, 既然只有一个节点不行的话, 那么就多加几个节点, 简单来说就是把所有东西都复制一份, 然后放到另外一个节点上

Kubernetes提供了一个叫做`Deployment`的组件, 它可以定义和管理应用程序的副本数量以及应用程序的更新策略, 可以简化应用程序的部署和更新操作

在之前我们提到过, pod可以理解为在容器的上面加了一层抽象, 这样就可以将一个或多个容器组合在一起, 而Deployment就可以理解为在pod上再加上一层抽象, 这样就可以将一个或者多个pod组合在一起, 并且还具有副本控制 滚动更新 自动扩缩容等高级特性和功能

> 副本控制是指可以定义和管理应用程序的副本数量, 比如我们可以定义一个应用程序的副本数量为3个, 那么如果有副本发生故障的时候, 会自动创建一个新的副本来替代它

对于管理数据库的持久化, kubernetes提供了另一个组件叫`StatefulSet`来保证数据库的高可用性, 用法根Deployment相似

StatefulSet适用于需要持久化存储、网络标识和有序操作的场景，例如数据库（如 MySQL、PostgreSQL）、消息队列（如 RabbitMQ、Kafka）和分布式存储系统等。

创建StatefulSet的基本 YAML 文件示例如下：

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  serviceName: "nginx"
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: k8s.gcr.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
```

在这个例子中，我们定义了一个名为 web的 StatefulSet，它管理了三个 nginx 的Pod，每个 Pod 都有一个名为 www 的持久卷

## Kubernetes架构

还在学习中, 更新未完待续.....